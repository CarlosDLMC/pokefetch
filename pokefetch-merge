#!/usr/bin/env python3
import sys
import re

# Read pokemon and system info from stdin (separated by delimiter)
input_data = sys.stdin.read()
parts = input_data.split('\n---DELIMITER---\n')
pokemon_output = parts[0]
neofetch_output = parts[1] if len(parts) > 1 else ""

# Strip ANSI codes for width calculation
ansi_escape = re.compile(r'\x1b(\[[0-9;]*[mGKHfA-Z]|\][0-9];[^\x07]*\x07)')

def visual_width(line):
    return len(ansi_escape.sub('', line))

# Split into lines
pokemon_lines = pokemon_output.split('\n')
neofetch_lines = neofetch_output.split('\n')

# Calculate max width of pokemon
max_width = max((visual_width(line) for line in pokemon_lines), default=0)

# Normalize pokemon lines to same width
normalized_pokemon = []
for line in pokemon_lines:
    width = visual_width(line)
    padding = ' ' * (max_width - width)
    normalized_pokemon.append(line + padding)

# Vertical centering
pokemon_count = len(normalized_pokemon)
neofetch_count = len(neofetch_lines)

if pokemon_count < neofetch_count:
    # Center pokemon vertically
    total_padding = neofetch_count - pokemon_count
    top_padding = total_padding // 2
    bottom_padding = total_padding - top_padding

    empty_line = ' ' * max_width
    normalized_pokemon = [empty_line] * top_padding + normalized_pokemon + [empty_line] * bottom_padding
elif neofetch_count < pokemon_count:
    # Pad neofetch
    neofetch_lines.extend([''] * (pokemon_count - neofetch_count))

# Merge side by side
for i in range(max(len(normalized_pokemon), len(neofetch_lines))):
    poke_line = normalized_pokemon[i] if i < len(normalized_pokemon) else ' ' * max_width
    neo_line = neofetch_lines[i] if i < len(neofetch_lines) else ''
    print(f"{poke_line}  {neo_line}")
